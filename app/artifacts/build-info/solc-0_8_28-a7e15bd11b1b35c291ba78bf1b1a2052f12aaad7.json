{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-a7e15bd11b1b35c291ba78bf1b1a2052f12aaad7",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/Error.sol": "project/contracts/Error.sol",
    "contracts/Kickstarter.sol": "project/contracts/Kickstarter.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/"
      ]
    },
    "sources": {
      "npm/@openzeppelin/contracts@5.4.0/utils/ReentrancyGuard.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
      },
      "project/contracts/Error.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.28;\r\n\r\nerror ProjectDoesNotExist();\r\nerror ProjectClosed();\r\nerror ContributionWindowOver();\r\nerror SelfContributionForbidden();\r\nerror ZeroValue();\r\nerror RefundFailed();\r\nerror OwnerPaymentFailed();\r\nerror GoalNotReached();\r\nerror EndMustBeInTheFuture();\r\nerror TooManyOpenProjects();\r\nerror InsufficientContractBalance();\r\nerror DirectEtherNotAllowed();\r\nerror NothingToWithdraw();\r\nerror NotEnoughBalance();\r\nerror ErrorSendingEther();\r\nerror NotTheOwner();\r\nerror ProjectBalanceNotEmpty();"
      },
      "project/contracts/Kickstarter.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.28;\n\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"./Error.sol\";\n\ncontract Kickstarter is ReentrancyGuard {\n    uint256 public immutable maxOpenProject;\n    uint256 private nextProjectId;\n\n    struct Project {\n        uint256 id;\n        bool isOpen;\n        uint48 endTimestamp;\n        address owner;\n        uint256 goal;\n        uint256 pledged;\n        uint256 withdrawn;\n        string title;\n    }\n\n    mapping(uint256 => Project) public projectsById;\n    mapping(address => uint256[]) public ownerProjectIds;\n    mapping(uint256 => mapping(address => uint256)) public contributions;\n\n    constructor(uint256 _maxOpenProjectByOwner) {\n        maxOpenProject = _maxOpenProjectByOwner;\n    }\n\n    function createProject(\n        string memory _title,\n        uint256 _goal,\n        uint48 _endTimestamp\n    ) external returns (uint256 id) {\n        if(bytes(_title).length == 0) revert ZeroValue();\n        if(_goal == 0) revert ZeroValue();\n        if(_endTimestamp <= block.timestamp) revert EndMustBeInTheFuture();\n        if(_openProjectsCount(msg.sender) >= maxOpenProject) revert TooManyOpenProjects();\n\n        id = ++nextProjectId;\n\n        projectsById[id] = Project({\n            id: id,\n            isOpen: true,\n            endTimestamp: _endTimestamp,\n            owner: msg.sender,\n            goal: _goal,\n            pledged: 0,\n            withdrawn: 0,\n            title: _title\n        });\n        ownerProjectIds[msg.sender].push(id);\n    }\n\n    // Accept up to the remaining goal amount; refund any surplus from the last contributor.\n    function contribute(uint256 _projectId) external nonReentrant payable {\n        Project storage project = projectsById[_projectId];\n\n        if (project.owner == address(0)) revert ProjectDoesNotExist();\n        if (!project.isOpen) revert ProjectClosed();\n        if (block.timestamp >= project.endTimestamp) revert ContributionWindowOver();\n        if (msg.sender == project.owner) revert SelfContributionForbidden();\n        if (msg.value == 0) revert ZeroValue();\n\n        // Determine accepted and surplus amounts before writing state\n        uint256 balanceBefore = project.pledged - project.withdrawn;\n        uint256 remaining = project.goal > balanceBefore ? (project.goal - balanceBefore) : 0;\n\n        uint256 accepted = msg.value <= remaining ? msg.value : remaining;\n        uint256 surplus = msg.value - accepted;\n\n        // Update state for accepted part only\n        if (accepted > 0) {\n            contributions[_projectId][msg.sender] += accepted;\n            project.pledged += accepted;\n        }\n\n        // Check if goal has been reached\n        bool goalReached = (project.pledged - project.withdrawn) >= project.goal;\n        if (goalReached) {\n            project.isOpen = false;\n        }\n\n        // Refund any surplus first\n        if (surplus > 0) {\n            (bool refunded, ) = payable(msg.sender).call{value: surplus}(\"\");\n            if (!refunded) revert RefundFailed();\n        }\n\n        // If funded, pay the owner\n        if (goalReached) {\n            _payOwner(_projectId);\n        }\n    }\n\n    /**\n     * Allow user to withdraw funds if project still open\n     */\n    function withdraw(uint256 _projectId, uint256 _amount) external nonReentrant{\n        Project storage project = projectsById[_projectId];\n        uint256 userContribution = contributions[_projectId][msg.sender];\n\n        if (project.owner == address(0)) revert ProjectDoesNotExist();\n        if (!project.isOpen) revert ProjectClosed();\n        if (_amount == 0) revert ZeroValue();\n        if (userContribution == 0) revert NothingToWithdraw();\n        if (userContribution < _amount) revert NotEnoughBalance();\n\n        // Change value & send\n        contributions[_projectId][msg.sender] = userContribution - _amount;\n        project.pledged -= _amount;\n\n        (bool withdrawTx,) = payable(msg.sender).call{value: _amount}(\"\");\n        if (!withdrawTx) { revert ErrorSendingEther(); }\n    }\n\n    function openProjectsByOwner(address _owner) external view returns (uint256) {\n        return _openProjectsCount(_owner);\n    }\n\n    function closeProject(uint256 _projectId) external {\n        // check sender is owner & check if open and balance empty then set isOpen to false\n        Project storage p = projectsById[_projectId];\n        if (p.owner == address(0)) { revert ProjectDoesNotExist(); }\n        if (msg.sender != p.owner) { revert NotTheOwner(); }\n        if (!p.isOpen || (p.pledged - p.withdrawn) != 0) { revert ProjectBalanceNotEmpty(); }\n\n        p.isOpen = false;\n    }\n\n    function getAll() external view returns (Project[] memory projects) {\n        projects = new Project[](nextProjectId);\n        for (uint256 i = 0; i < nextProjectId; i++) {\n            projects[i] = projectsById[i + 1];\n        }\n        return projects;\n    }\n\n    // ---------------------- Helpers ---------------------- //\n\n    function _openProjectsCount(address _owner) internal view returns (uint256 count) {\n        uint256[] storage ids = ownerProjectIds[_owner];\n        for (uint256 i = 0; i < ids.length; i++) {\n            if (projectsById[ids[i]].isOpen) {\n                unchecked {\n                    count++;\n                }\n            }\n        }\n    }\n\n    function _getProjectBalance(uint256 _projectId) internal view returns (uint256) {\n        Project storage project = projectsById[_projectId];\n        return project.pledged - project.withdrawn;\n    }\n\n    function _payOwner(uint256 _projectId) internal {\n        Project storage project = projectsById[_projectId];\n        if (project.isOpen) revert GoalNotReached();\n\n        uint256 toPay = project.goal - project.withdrawn;\n        if (toPay == 0) return;\n\n        project.withdrawn += toPay;\n\n        if (address(this).balance < toPay) revert InsufficientContractBalance();\n        (bool success, ) = payable(project.owner).call{value: toPay}(\"\");\n        if (!success) revert OwnerPaymentFailed();\n    }\n\n    receive() external payable { revert DirectEtherNotAllowed(); }\n    fallback() external payable { revert DirectEtherNotAllowed(); }\n}"
      }
    }
  }
}